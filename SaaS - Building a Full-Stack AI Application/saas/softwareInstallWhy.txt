1. Next.js (App Router) â€” INSTALL

Status: ğŸŸ¢ Mandatory

Why it stays

Server Components = less JS, better perf

Native routing, layouts, streaming

Industry standard for modern SaaS

Rules

Server by default

Client only for interaction

No â€œuse client everywhereâ€ laziness

If you canâ€™t explain server/client boundaries, you donâ€™t deserve this tool yet.

2. TypeScript â€” INSTALL

Status: ğŸŸ¢ Non-negotiable

Why

Prevents silent runtime bugs

Forces explicit contracts

Scales with team size

Hard rule
If youâ€™re using any, youâ€™re lying to yourself.

3. ESLint â€” INSTALL

Status: ğŸŸ¢ Mandatory guardrail

Why

Catches bugs before runtime

Enforces React + Next best practices

Stops â€œworks on my machineâ€ nonsense

Rule
Fix warnings early. Donâ€™t suppress them.

4. Tailwind CSS â€” INSTALL

Status: ğŸŸ¢ Correct choice for SaaS

Why

Zero CSS sprawl

Faster iteration

Easy design systems

Rules

No massive class soup

Extract reusable UI components

No inline styling chaos

Tailwind is powerful â€” abuse it and your code becomes unreadable.

5. src/ Directory â€” INSTALL

Status: ğŸŸ¢ Always yes

Why

Clean separation of concerns

Scales cleanly

Industry-standard layout

Anyone arguing against this is optimizing for tutorials.

6. App Router â€” INSTALL

Status: ğŸŸ¢ Future-proof

Why

Server Components

Streaming

Better data fetching

First-class layouts

Rule
Learn it properly or suffer later.

7. Import Alias (@/*) â€” INSTALL

Status: ğŸŸ¢ Small but critical

Why

Clean imports

Easier refactors

Less path hell

Stick with @/. Donâ€™t invent cute aliases.

8. React Compiler â€” DO NOT INSTALL

Status: ğŸ”´ Reject (for now)

Why

Experimental

Hides React fundamentals

Solves problems you donâ€™t have yet

Install only when:

You have real performance metrics

You understand manual optimization

Until then, itâ€™s a liability.

9. npm (default) â€” ACCEPTABLE

Status: ğŸŸ¡ Fine for now

Why

Works everywhere

No learning overhead

Upgrade later

pnpm when monorepo or speed matters

Donâ€™t over-optimize tooling on day one.